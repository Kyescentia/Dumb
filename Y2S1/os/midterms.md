### **Midterm Test Details / æœŸä¸­è€ƒè¯•é‡ç‚¹æ‘˜è¦** 

*   **Test (è€ƒè¯•):** Mid-term Test (Chapters 1 to 3) / æœŸä¸­è€ƒè¯• (ç¬¬1è‡³3ç« )
*   **Weightage (åˆ†æ•°å æ¯”):** 50% of your final grade / å æ€»æˆç»©çš„ 50%
*   **Marks (åˆ†æ•°):** 50
*   **Date (æ—¥æœŸ):** Monday, 18/8/2025 (Week 9) / 2025å¹´8æœˆ18æ—¥ï¼Œæ˜ŸæœŸä¸€ (ç¬¬ä¹å‘¨)
*   **Time (æ—¶é—´):** 3:15 PM - 4:45 PM
*   **Duration (æ—¶é•¿):** 1 hour 30 minutes / 1å°æ—¶30åˆ†é’Ÿ
*   **Venue (åœ°ç‚¹):** M003 & M004

---

## **Chapter 1: System Software & OS Introduction / ç³»ç»Ÿè½¯ä»¶ä¸æ“ä½œç³»ç»Ÿç®€ä»‹**

### **1. Core Concepts / æ ¸å¿ƒæ¦‚å¿µ**

*   **Computer System Components / è®¡ç®—æœºç³»ç»Ÿç»„ä»¶**
    *   **EN:** The system is composed of hardware, software, and users.
    *   **ä¸­æ–‡:** ç³»ç»Ÿç”±ç¡¬ä»¶ã€è½¯ä»¶å’Œç”¨æˆ·ç»„æˆã€‚
*   **System Software vs. Application Software / ç³»ç»Ÿè½¯ä»¶ vs. åº”ç”¨è½¯ä»¶**
    *   **System Software / ç³»ç»Ÿè½¯ä»¶**
        *   **EN:** Operates the computer hardware and provides a platform for applications (e.g., OS, BIOS). It is the foundation.
        *   **ä¸­æ–‡:** æ“ä½œè®¡ç®—æœºç¡¬ä»¶å¹¶ä¸ºåº”ç”¨ç¨‹åºæä¾›å¹³å°çš„è½¯ä»¶ (ä¾‹å¦‚ï¼šæ“ä½œç³»ç»Ÿã€BIOS)ã€‚å®ƒæ˜¯ç³»ç»Ÿçš„åŸºç¡€ã€‚
    *   **Application Software / åº”ç”¨è½¯ä»¶**
        *   **EN:** Programs designed for specific user tasks (e.g., Word, Chrome, games). They run on top of the system software.
        *   **ä¸­æ–‡:** ä¸ºç”¨æˆ·æ‰§è¡Œç‰¹å®šä»»åŠ¡è€Œè®¾è®¡çš„ç¨‹åº (ä¾‹å¦‚ï¼šWord, Chrome, æ¸¸æˆ)ã€‚å®ƒä»¬è¿è¡Œåœ¨ç³»ç»Ÿè½¯ä»¶ä¹‹ä¸Šã€‚
*   **Operating System (OS) / æ“ä½œç³»ç»Ÿ**
    *   **EN:** The most important system software that acts as an intermediary between the user/applications and the hardware. It manages all resources.
    *   **ä¸­æ–‡:** æœ€é‡è¦çš„ç³»ç»Ÿè½¯ä»¶ï¼Œä½œä¸ºç”¨æˆ·/åº”ç”¨ç¨‹åºå’Œç¡¬ä»¶ä¹‹é—´çš„ä¸­ä»‹ã€‚å®ƒç®¡ç†æ‰€æœ‰èµ„æºã€‚

### **2. OS Managers (Subsystems) / æ“ä½œç³»ç»Ÿç®¡ç†å™¨ (å­ç³»ç»Ÿ)**

*   **Processor Manager / å¤„ç†å™¨ç®¡ç†å™¨**
    *   **EN:** Manages the CPU, deciding which process gets CPU time and for how long.
    *   **ä¸­æ–‡:** ç®¡ç†ä¸­å¤®å¤„ç†å™¨ (CPU)ï¼Œå†³å®šå“ªä¸ªè¿›ç¨‹ä»¥åŠä½•æ—¶è·å¾—CPUæ—¶é—´ã€‚
*   **Memory Manager / å†…å­˜ç®¡ç†å™¨**
    *   **EN:** Manages RAM by allocating memory to processes and ensuring protection.
    *   **ä¸­æ–‡:** é€šè¿‡ä¸ºè¿›ç¨‹åˆ†é…å†…å­˜å¹¶ç¡®ä¿å†…å­˜ä¿æŠ¤æ¥ç®¡ç†RAM (å†…å­˜)ã€‚
*   **Device Manager / è®¾å¤‡ç®¡ç†å™¨**
    *   **EN:** Manages all I/O devices like keyboards, printers, and disk drives.
    *   **ä¸­æ–‡:** ç®¡ç†æ‰€æœ‰è¾“å…¥/è¾“å‡ºè®¾å¤‡ï¼Œå¦‚é”®ç›˜ã€æ‰“å°æœºå’Œç£ç›˜é©±åŠ¨å™¨ã€‚
*   **File Manager / æ–‡ä»¶ç®¡ç†å™¨**
    *   **EN:** Manages files and directories, controlling access and permissions.
    *   **ä¸­æ–‡:** ç®¡ç†æ–‡ä»¶å’Œç›®å½•ï¼Œæ§åˆ¶è®¿é—®æƒé™ã€‚

### **3. Types of Operating Systems / æ“ä½œç³»ç»Ÿçš„ç±»å‹**

*   **Batch Systems / æ‰¹å¤„ç†ç³»ç»Ÿ**
    *   **EN:** Processes a batch of similar jobs serially without user interaction. Focuses on throughput.
    *   **ä¸­æ–‡:** æ— éœ€ç”¨æˆ·äº¤äº’ï¼ŒæŒ‰æ‰¹æ¬¡é¡ºåºå¤„ç†ç›¸ä¼¼çš„ä½œä¸šã€‚æ³¨é‡ååé‡ã€‚
*   **Time-Sharing (Interactive) Systems / åˆ†æ—¶ (äº¤äº’å¼) ç³»ç»Ÿ**
    *   **EN:** Allows multiple users to interact with the system at the same time by quickly switching between jobs.
    *   **ä¸­æ–‡:** é€šè¿‡åœ¨ä½œä¸šä¹‹é—´å¿«é€Ÿåˆ‡æ¢ï¼Œå…è®¸å¤šä¸ªç”¨æˆ·åŒæ—¶ä¸ç³»ç»Ÿè¿›è¡Œäº¤äº’ã€‚
*   **Real-Time Systems / å®æ—¶ç³»ç»Ÿ**
    *   **EN:** Used in time-critical environments where data must be processed within a strict time limit (e.g., airport traffic control).
    *   **ä¸­æ–‡:** ç”¨äºæ—¶é—´å…³é”®å‹ç¯å¢ƒï¼Œæ•°æ®å¿…é¡»åœ¨ä¸¥æ ¼çš„æ—¶é—´é™åˆ¶å†…å¤„ç† (ä¾‹å¦‚ï¼šæœºåœºäº¤é€šç®¡åˆ¶)ã€‚

### **4. Key OS Operations / å…³é”®çš„æ“ä½œç³»ç»Ÿæ“ä½œ**

*   **Dual-Mode Operation / åŒæ¨¡å¼æ“ä½œ**
    *   **EN:** The OS switches between user mode (for applications) and kernel mode (for OS tasks) to protect system resources.
    *   **ä¸­æ–‡:** æ“ä½œç³»ç»Ÿåœ¨ç”¨æˆ·æ¨¡å¼ (ç”¨äºåº”ç”¨ç¨‹åº) å’Œå†…æ ¸æ¨¡å¼ (ç”¨äºæ“ä½œç³»ç»Ÿä»»åŠ¡) ä¹‹é—´åˆ‡æ¢ï¼Œä»¥ä¿æŠ¤ç³»ç»Ÿèµ„æºã€‚
*   **Interrupts / ä¸­æ–­**
    *   **EN:** A signal from hardware or software that diverts the CPU to handle an important event.
    *   **ä¸­æ–‡:** æ¥è‡ªç¡¬ä»¶æˆ–è½¯ä»¶çš„ä¿¡å·ï¼Œä½¿CPUè½¬å»å¤„ç†ä¸€ä¸ªé‡è¦äº‹ä»¶ã€‚

---

## **Chapter 2: Processor Management / å¤„ç†å™¨ç®¡ç†**

### **1. Processes & Schedulers / è¿›ç¨‹ä¸è°ƒåº¦å™¨**

*   **Program vs. Process / ç¨‹åº vs. è¿›ç¨‹**
    *   **EN:** A program is inactive code on a disk. A process is a program in execution.
    *   **ä¸­æ–‡:** ç¨‹åºæ˜¯ç£ç›˜ä¸Šçš„é™æ€ä»£ç ã€‚è¿›ç¨‹æ˜¯æ­£åœ¨æ‰§è¡Œä¸­çš„ç¨‹åºã€‚
*   **Schedulers / è°ƒåº¦å™¨**
    *   **Job Scheduler (Long-Term) / ä½œä¸šè°ƒåº¦å™¨ (é•¿æœŸ)**
        *   **EN:** Selects which jobs from the disk are loaded into memory's READY queue.
        *   **ä¸­æ–‡:** ä»ç£ç›˜ä¸­é€‰æ‹©ä½œä¸šåŠ è½½åˆ°å†…å­˜çš„å°±ç»ªé˜Ÿåˆ—ä¸­ã€‚
    *   **Process Scheduler (Short-Term) / è¿›ç¨‹è°ƒåº¦å™¨ (çŸ­æœŸ)**
        *   **EN:** Selects the next process from the READY queue to be executed by the CPU.
        *   **ä¸­æ–‡:** ä»å°±ç»ªé˜Ÿåˆ—ä¸­é€‰æ‹©ä¸‹ä¸€ä¸ªå°†ç”±CPUæ‰§è¡Œçš„è¿›ç¨‹ã€‚
*   **Process Control Block (PCB) / è¿›ç¨‹æ§åˆ¶å—**
    *   **EN:** A data structure that stores all information about a process, such as its state, ID, and registers.
    *   **ä¸­æ–‡:** ä¸€ç§æ•°æ®ç»“æ„ï¼Œç”¨äºå­˜å‚¨å…³äºä¸€ä¸ªè¿›ç¨‹çš„æ‰€æœ‰ä¿¡æ¯ï¼Œå¦‚çŠ¶æ€ã€IDå’Œå¯„å­˜å™¨å†…å®¹ã€‚
*   **Context Switching / ä¸Šä¸‹æ–‡åˆ‡æ¢**
    *   **EN:** The mechanism of saving the state of the current process (into its PCB) and loading the state of the next process.
    *   **ä¸­æ–‡:** ä¿å­˜å½“å‰è¿›ç¨‹çš„çŠ¶æ€ (åˆ°å…¶PCBä¸­) å¹¶åŠ è½½ä¸‹ä¸€ä¸ªè¿›ç¨‹çš„çŠ¶æ€çš„æœºåˆ¶ã€‚

### **2. Scheduling Policies & Algorithms / è°ƒåº¦ç­–ç•¥ä¸ç®—æ³• ğŸ§ **

*   **Scheduling Policies / è°ƒåº¦ç­–ç•¥**
    *   **Non-Preemptive / éæŠ¢å å¼**
        *   **EN:** Once a process starts, it keeps the CPU until it finishes or voluntarily gives it up.
        *   **ä¸­æ–‡:** ä¸€æ—¦è¿›ç¨‹å¼€å§‹è¿è¡Œï¼Œå®ƒå°†ä¸€ç›´å ç”¨CPUï¼Œç›´åˆ°å®Œæˆæˆ–è‡ªæ„¿æ”¾å¼ƒã€‚
        *   ğŸ”— [Example of NPP](https://github.com/Kyescentia/Dumb/blob/main/Y2S1/os/PPnNPP.md#1-non-preemptive-priority--%E9%9D%9E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6)
    *   **Preemptive / æŠ¢å å¼**
        *   **EN:** The OS can interrupt a running process and force it to give up the CPU.
        *   **ä¸­æ–‡:** æ“ä½œç³»ç»Ÿå¯ä»¥ä¸­æ–­ä¸€ä¸ªæ­£åœ¨è¿è¡Œçš„è¿›ç¨‹ï¼Œå¼ºåˆ¶å…¶æ”¾å¼ƒCPUã€‚
       *   ğŸ”— [Example of PP](https://github.com/Kyescentia/Dumb/blob/main/Y2S1/os/PPnNPP.md#2-preemptive-priority--%E6%8A%A2%E5%8D%A0%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6)

*   **Scheduling Algorithms / è°ƒåº¦ç®—æ³•**
    *   **First-Come, First-Served (FCFS) / å…ˆåˆ°å…ˆå¾—**
        *   **EN:** A non-preemptive algorithm where processes are executed in the order they arrive.
        *   **ä¸­æ–‡:** ä¸€ç§éæŠ¢å å¼ç®—æ³•ï¼Œè¿›ç¨‹æŒ‰å…¶åˆ°è¾¾çš„é¡ºåºæ‰§è¡Œã€‚
        *   ğŸ”— [Example of FCFS](https://github.com/Kyescentia/Dumb/blob/main/Y2S1/os/schedulingalgorithms.md#1-fcfs-first-come-first-served--%E5%85%88%E5%88%B0%E5%85%88%E5%BE%97)
    *   **Shortest Job Next (SJN) / æœ€çŸ­ä½œä¸šä¼˜å…ˆ**
        *   **EN:** A non-preemptive algorithm that selects the waiting process with the smallest estimated execution time.
        *   **ä¸­æ–‡:** ä¸€ç§éæŠ¢å å¼ç®—æ³•ï¼Œé€‰æ‹©ç­‰å¾…é˜Ÿåˆ—ä¸­é¢„è®¡æ‰§è¡Œæ—¶é—´æœ€çŸ­çš„è¿›ç¨‹ã€‚
        *   ğŸ”— [Example of SJN](https://github.com/Kyescentia/Dumb/blob/main/Y2S1/os/schedulingalgorithms.md#2-sjn-shortest-job-next--%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88)
    *   **Shortest Remaining Time (SRT) / æœ€çŸ­å‰©ä½™æ—¶é—´**
        *   **EN:** The preemptive version of SJN. It switches to a new process if it has a shorter remaining time than the current one.
        *   **ä¸­æ–‡:** SJNçš„æŠ¢å å¼ç‰ˆæœ¬ã€‚å¦‚æœæ–°åˆ°è¾¾çš„è¿›ç¨‹æ¯”å½“å‰è¿›ç¨‹çš„å‰©ä½™æ—¶é—´æ›´çŸ­ï¼Œåˆ™åˆ‡æ¢åˆ°æ–°è¿›ç¨‹ã€‚
        *   ğŸ”— [Example of SRT](https://github.com/Kyescentia/Dumb/blob/main/Y2S1/os/schedulingalgorithms.md#3-srt-shortest-remaining-time--%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4)
    *   **Round Robin (RR) / è½®è¯¢è°ƒåº¦**
        *   **EN:** A preemptive algorithm where each process gets a small unit of CPU time (time quantum).
        *   **ä¸­æ–‡:** ä¸€ç§æŠ¢å å¼ç®—æ³•ï¼Œæ¯ä¸ªè¿›ç¨‹è¢«åˆ†é…ä¸€ä¸ªå°çš„CPUæ—¶é—´å•ä½ (æ—¶é—´ç‰‡)ã€‚
        *   ğŸ”— [Example of RR](https://github.com/Kyescentia/Dumb/blob/main/Y2S1/os/schedulingalgorithms.md#4-rr-round-robin--%E8%BD%AE%E8%AF%A2%E8%B0%83%E5%BA%A6)

### **3. Important Formulas / é‡è¦è®¡ç®—å…¬å¼**

*   **Turnaround Time / å‘¨è½¬æ—¶é—´**
    *   **EN:** Calculated as: `Finish Time` â€“ `Arrival Time`.
    *   **ä¸­æ–‡:** è®¡ç®—å…¬å¼ä¸º: `å®Œæˆæ—¶é—´` â€“ `åˆ°è¾¾æ—¶é—´`ã€‚
*   **Waiting Time / ç­‰å¾…æ—¶é—´**
    *   **EN:** Calculated as: `Finish Time` â€“ `CPU Cycle` â€“ `Arrival Time`.
    *   **ä¸­æ–‡:** è®¡ç®—å…¬å¼ä¸º: `å®Œæˆæ—¶é—´` â€“ `CPUå‘¨æœŸ` â€“ `åˆ°è¾¾æ—¶é—´`ã€‚

---

### **Chapter 3: Deadlock / ç¬¬ä¸‰ç« ï¼šæ­»é”**

#### **1. What is Deadlock? / ä»€ä¹ˆæ˜¯æ­»é”ï¼Ÿ**

*   **Definition / å®šä¹‰**
    *   **EN:** A situation where a set of two or more processes are permanently blocked because each process is holding a resource and waiting for another resource that is held by another process in the same set. It is also called a "deadly embrace."
    *   **ä¸­æ–‡:** ä¸€ç§çŠ¶æ€ï¼Œå…¶ä¸­ä¸¤ä¸ªæˆ–å¤šä¸ªè¿›ç¨‹è¢«æ°¸ä¹…é˜»å¡ï¼Œå› ä¸ºæ¯ä¸ªè¿›ç¨‹éƒ½æŒæœ‰ä¸€ä¸ªèµ„æºï¼ŒåŒæ—¶åˆåœ¨ç­‰å¾…è¯¥é›†åˆä¸­å¦ä¸€ä¸ªè¿›ç¨‹æ‰€æŒæœ‰çš„å¦ä¸€ä¸ªèµ„æºã€‚å®ƒä¹Ÿè¢«ç§°ä¸ºâ€œæ­»é”æ‹¥æŠ±â€ã€‚
*   **Key Characteristics / å…³é”®ç‰¹å¾**
    *   **EN:** Deadlock is more serious than starvation because it affects multiple processes and will never resolve on its own. It requires external intervention (e.g., terminating a process) to be broken.
    *   **ä¸­æ–‡:** æ­»é”æ¯”é¥¥é¥¿æ›´ä¸¥é‡ï¼Œå› ä¸ºå®ƒå½±å“å¤šä¸ªè¿›ç¨‹ï¼Œå¹¶ä¸”æ°¸è¿œæ— æ³•è‡ªè¡Œè§£å†³ã€‚å®ƒéœ€è¦å¤–éƒ¨å¹²é¢„ï¼ˆä¾‹å¦‚ï¼Œç»ˆæ­¢ä¸€ä¸ªè¿›ç¨‹ï¼‰æ‰èƒ½è¢«æ‰“ç ´ã€‚

---

#### **2. The Four Necessary Conditions for Deadlock / æ­»é”çš„å››ä¸ªå¿…è¦æ¡ä»¶**

*   **EN:** For a deadlock to occur, all four of these conditions must be met simultaneously.
*   **ä¸­æ–‡:** æ­»é”çš„å‘ç”Ÿå¿…é¡»**åŒæ—¶æ»¡è¶³**ä»¥ä¸‹æ‰€æœ‰å››ä¸ªæ¡ä»¶ã€‚

1.  **Mutual Exclusion / äº’æ–¥æ¡ä»¶**
    *   **EN:** At least one resource must be non-sharable, meaning only one process can use it at a time.
    *   **ä¸­æ–‡:** è‡³å°‘æœ‰ä¸€ä¸ªèµ„æºå¿…é¡»æ˜¯éå…±äº«çš„ï¼Œæ„å‘³ç€ä¸€æ¬¡åªæœ‰ä¸€ä¸ªè¿›ç¨‹å¯ä»¥ä½¿ç”¨å®ƒã€‚ï¼ˆä¾‹å¦‚ï¼šæ‰“å°æœºï¼‰ã€‚
2.  **Hold and Wait / å æœ‰å¹¶ç­‰å¾…**
    *   **EN:** A process is holding at least one resource while waiting to acquire additional resources that are currently being held by other processes.
    *   **ä¸­æ–‡:** ä¸€ä¸ªè¿›ç¨‹è‡³å°‘æŒæœ‰ä¸€ä¸ªèµ„æºï¼ŒåŒæ—¶åˆåœ¨ç­‰å¾…è·å–å½“å‰è¢«å…¶ä»–è¿›ç¨‹æŒæœ‰çš„é¢å¤–èµ„æºã€‚
3.  **No Preemption / ä¸å¯æŠ¢å **
    *   **EN:** A resource cannot be forcibly taken away from the process holding it. It can only be released voluntarily by the process.
    *   **ä¸­æ–‡:** èµ„æºä¸èƒ½è¢«å¼ºåˆ¶æ€§åœ°ä»æŒæœ‰å®ƒçš„è¿›ç¨‹ä¸­å¤ºèµ°ã€‚å®ƒåªèƒ½ç”±è¯¥è¿›ç¨‹è‡ªæ„¿é‡Šæ”¾ã€‚
4.  **Circular Wait / å¾ªç¯ç­‰å¾…**
    *   **EN:** A set of waiting processes {P0, P1, ..., Pn} exists such that P0 is waiting for a resource held by P1, P1 is waiting for a resource held by P2, ..., and Pn is waiting for a resource held by P0.
    *   **ä¸­æ–‡:** å­˜åœ¨ä¸€ä¸ªç­‰å¾…è¿›ç¨‹çš„å¾ªç¯é“¾ {P0, P1, ..., Pn}ï¼Œå…¶ä¸­P0åœ¨ç­‰å¾…P1æŒæœ‰çš„èµ„æºï¼ŒP1åœ¨ç­‰å¾…P2æŒæœ‰çš„èµ„æºï¼Œ...ï¼Œè€ŒPnåœ¨ç­‰å¾…P0æŒæœ‰çš„èµ„æºã€‚

---

#### **3. Modeling Deadlocks: Resource-Allocation Graphs / æ­»é”å»ºæ¨¡ï¼šèµ„æºåˆ†é…å›¾**

*   **EN:** We can visualize the state of the system using a directed graph.
*   **ä¸­æ–‡:** æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æœ‰å‘å›¾æ¥å¯è§†åŒ–ç³»ç»Ÿçš„çŠ¶æ€ã€‚
    *   **Process (è¿›ç¨‹):** Represented by a circle / ç”¨åœ†å½¢è¡¨ç¤ºã€‚
    *   **Resource (èµ„æº):** Represented by a square / ç”¨æ–¹å½¢è¡¨ç¤ºã€‚
    *   **Request Edge (è¯·æ±‚è¾¹):** An arrow from a process to a resource (`P â†’ R`) means the process is requesting that resource. / ä»è¿›ç¨‹æŒ‡å‘èµ„æºçš„ç®­å¤´ (`P â†’ R`) è¡¨ç¤ºè¯¥è¿›ç¨‹æ­£åœ¨è¯·æ±‚è¯¥èµ„æºã€‚
    *   **Assignment Edge (åˆ†é…è¾¹):** An arrow from a resource to a process (`R â†’ P`) means the resource has been allocated to that process. / ä»èµ„æºæŒ‡å‘è¿›ç¨‹çš„ç®­å¤´ (`R â†’ P`) è¡¨ç¤ºè¯¥èµ„æºå·²è¢«åˆ†é…ç»™è¯¥è¿›ç¨‹ã€‚

*   **Key Rule / å…³é”®è§„åˆ™**
    *   **EN:** If the graph contains a **cycle**, a deadlock exists. If there is no cycle, the system is not deadlocked.
    *   **ä¸­æ–‡:** å¦‚æœå›¾ä¸­åŒ…å«ä¸€ä¸ª**ç¯è·¯ï¼ˆcycleï¼‰**ï¼Œåˆ™å­˜åœ¨æ­»é”ã€‚å¦‚æœæ²¡æœ‰ç¯è·¯ï¼Œç³»ç»Ÿå°±æ²¡æœ‰æ­»é”ã€‚

*   **Example / ç¤ºä¾‹:**
    *   **EN:** P1 holds R1 and wants R2. P2 holds R2 and wants R1.
    *   **ä¸­æ–‡:** P1æŒæœ‰R1å¹¶æƒ³è¦R2ã€‚P2æŒæœ‰R2å¹¶æƒ³è¦R1ã€‚

    **Text-based Visualization / æ–‡æœ¬å¯è§†åŒ–:**
    ```
           waits for / ç­‰å¾…
       P1 ----------> [ R2 ]
       ^              |
       |              |
     holds / å æœ‰     holds / å æœ‰
       |              |
       |              v
     [ R1 ] <---------- P2
           waits for / ç­‰å¾…
    ```
    *   **EN:** The cycle `P1 â†’ R2 â†’ P2 â†’ R1 â†’ P1` clearly indicates a deadlock.
    *   **ä¸­æ–‡:** ç¯è·¯ `P1 â†’ R2 â†’ P2 â†’ R1 â†’ P1` æ¸…æ™°åœ°è¡¨æ˜äº†æ­»é”çš„å­˜åœ¨ã€‚

---

#### **4. Strategies for Handling Deadlocks / å¤„ç†æ­»é”çš„ç­–ç•¥**

##### **a) Deadlock Prevention / æ­»é”é¢„é˜²**

*   **EN:** Design the system to break one of the four necessary conditions, making deadlock impossible.
*   **ä¸­æ–‡:** é€šè¿‡ç ´åå››ä¸ªå¿…è¦æ¡ä»¶ä¹‹ä¸€æ¥è®¾è®¡ç³»ç»Ÿï¼Œä½¿æ­»é”ä¸å¯èƒ½å‘ç”Ÿã€‚
    1.  **Break Mutual Exclusion:** Make resources sharable (not always possible, e.g., for a printer). / æ‰“ç ´äº’æ–¥ï¼šä½¿èµ„æºå¯å…±äº«ï¼ˆä½†å¹¶éæ‰€æœ‰èµ„æºéƒ½å¯è¡Œï¼Œå¦‚æ‰“å°æœºï¼‰ã€‚
    2.  **Break Hold and Wait:** Require a process to request all its resources at once, or to release all held resources before requesting new ones. / æ‰“ç ´å æœ‰å¹¶ç­‰å¾…ï¼šè¦æ±‚è¿›ç¨‹ä¸€æ¬¡æ€§è¯·æ±‚æ‰€æœ‰èµ„æºï¼Œæˆ–åœ¨è¯·æ±‚æ–°èµ„æºå‰é‡Šæ”¾æ‰€æœ‰å·²æŒæœ‰çš„èµ„æºã€‚
    3.  **Break No Preemption:** If a process requests a resource that is unavailable, it must release all resources it currently holds. / æ‰“ç ´ä¸å¯æŠ¢å ï¼šå¦‚æœä¸€ä¸ªè¿›ç¨‹è¯·æ±‚çš„èµ„æºä¸å¯ç”¨ï¼Œå®ƒå¿…é¡»é‡Šæ”¾å½“å‰æŒæœ‰çš„æ‰€æœ‰èµ„æºã€‚
    4.  **Break Circular Wait:** Impose a total ordering of all resource types and require that each process requests resources in an increasing order of enumeration (Havender's solution). / æ‰“ç ´å¾ªç¯ç­‰å¾…ï¼šå¯¹æ‰€æœ‰èµ„æºç±»å‹è¿›è¡Œå…¨å±€æ’åºï¼Œå¹¶è¦æ±‚æ¯ä¸ªè¿›ç¨‹æŒ‰é€’å¢çš„é¡ºåºè¯·æ±‚èµ„æºï¼ˆHavenderè§£å†³æ–¹æ¡ˆï¼‰ã€‚

##### **b) Deadlock Avoidance / æ­»é”é¿å…**

*   **EN:** The OS uses prior information about the maximum resources a process might need to decide whether granting a request is "safe." The goal is to never enter an unsafe state.
*   **ä¸­æ–‡:** æ“ä½œç³»ç»Ÿä½¿ç”¨å…³äºè¿›ç¨‹å¯èƒ½éœ€è¦çš„æœ€å¤§èµ„æºçš„å…ˆéªŒä¿¡æ¯ï¼Œæ¥å†³å®šæ‰¹å‡†ä¸€ä¸ªè¯·æ±‚æ˜¯å¦â€œå®‰å…¨â€ã€‚ç›®æ ‡æ˜¯æ°¸è¿œä¸è¿›å…¥ä¸å®‰å…¨çŠ¶æ€ã€‚
    *   **Main Tool / ä¸»è¦å·¥å…·:** **Banker's Algorithm**. / **é“¶è¡Œå®¶ç®—æ³•**ã€‚
    *   **EN:** It checks if granting a request will leave the system in a **safe state** (a state where there is at least one sequence for all processes to finish). If not, the request is denied.
    *   **ä¸­æ–‡:** å®ƒæ£€æŸ¥æ‰¹å‡†ä¸€ä¸ªè¯·æ±‚åç³»ç»Ÿæ˜¯å¦ä¼šå¤„äº**å®‰å…¨çŠ¶æ€**ï¼ˆå³å­˜åœ¨è‡³å°‘ä¸€ä¸ªèƒ½è®©æ‰€æœ‰è¿›ç¨‹éƒ½å®Œæˆçš„åºåˆ—ï¼‰ã€‚å¦‚æœä¸æ˜¯ï¼Œåˆ™è¯·æ±‚è¢«æ‹’ç»ã€‚

##### **c) Deadlock Detection and Recovery / æ­»é”æ£€æµ‹ä¸æ¢å¤**

*   **EN:** Allow the system to enter a deadlock, then detect it and recover.
*   **ä¸­æ–‡:** å…è®¸ç³»ç»Ÿè¿›å…¥æ­»é”çŠ¶æ€ï¼Œç„¶åæ£€æµ‹åˆ°å®ƒå¹¶è¿›è¡Œæ¢å¤ã€‚
    *   **Detection / æ£€æµ‹:** Periodically check for cycles in the resource-allocation graph. / å®šæœŸæ£€æŸ¥èµ„æºåˆ†é…å›¾ä¸­æ˜¯å¦å­˜åœ¨ç¯è·¯ã€‚
    *   **Recovery / æ¢å¤:**
        1.  **Process Termination / ç»ˆæ­¢è¿›ç¨‹:** Abort one or more processes in the deadlock cycle. / ä¸­æ­¢æ­»é”ç¯è·¯ä¸­çš„ä¸€ä¸ªæˆ–å¤šä¸ªè¿›ç¨‹ã€‚
        2.  **Resource Preemption / èµ„æºæŠ¢å :** Forcibly take away resources from some processes and give them to others until the deadlock cycle is broken. / ä»æŸäº›è¿›ç¨‹ä¸­å¼ºåˆ¶æ€§åœ°æ”¶å›èµ„æºï¼Œå¹¶å°†å…¶åˆ†é…ç»™å…¶ä»–è¿›ç¨‹ï¼Œç›´åˆ°æ­»é”ç¯è·¯è¢«æ‰“ç ´ã€‚

---

#### **5. Deadlock vs. Starvation / æ­»é” vs. é¥¥é¥¿**

*   **Deadlock / æ­»é”**
    *   **EN:** A process is blocked and can **never** run again because it is waiting for a resource held by another waiting process in a circular chain.
    *   **ä¸­æ–‡:** ä¸€ä¸ªè¿›ç¨‹è¢«é˜»å¡ï¼Œå¹¶ä¸”**æ°¸è¿œ**æ— æ³•å†æ¬¡è¿è¡Œï¼Œå› ä¸ºå®ƒæ­£åœ¨ç­‰å¾…ä¸€ä¸ªå¾ªç¯é“¾ä¸­å¦ä¸€ä¸ªç­‰å¾…è¿›ç¨‹æ‰€æŒæœ‰çš„èµ„æºã€‚
*   **Starvation / é¥¥é¥¿**
    *   **EN:** A process is overlooked or repeatedly postponed by the scheduler but is **not technically blocked**. It *could* run, but high-priority processes keep arriving and taking its place. It's a problem of indefinite postponement.
    *   **ä¸­æ–‡:** ä¸€ä¸ªè¿›ç¨‹è¢«è°ƒåº¦å™¨å¿½ç•¥æˆ–åå¤æ¨è¿Ÿï¼Œä½†**æŠ€æœ¯ä¸Šå¹¶æœªè¢«é˜»å¡**ã€‚å®ƒ*æœ¬å¯ä»¥*è¿è¡Œï¼Œä½†é«˜ä¼˜å…ˆçº§çš„è¿›ç¨‹ä¸æ–­åˆ°è¾¾å¹¶æŠ¢å äº†å®ƒçš„ä½ç½®ã€‚è¿™æ˜¯ä¸€ä¸ªæ— é™æœŸå»¶è¿Ÿçš„é—®é¢˜ã€‚
    *   **Solution / è§£å†³æ–¹æ¡ˆ:** **Aging (è€åŒ–)** - gradually increasing the priority of processes that wait for a long time. / **è€åŒ–** - é€æ¸æé«˜ç­‰å¾…æ—¶é—´é•¿çš„è¿›ç¨‹çš„ä¼˜å…ˆçº§ã€‚

---

### **Banker's Algorithm Example / é“¶è¡Œå®¶ç®—æ³•ç¤ºä¾‹**

#### **Definition and Goal / å®šä¹‰ä¸ç›®æ ‡**

*   **EN:** The Banker's Algorithm is a **deadlock avoidance** algorithm. It ensures the system is always in a **"safe state"**. A safe state is one where there exists at least one sequence of execution that allows all processes to complete without deadlocking. If a resource request leads to an unsafe state, the request is denied.
*   **ä¸­æ–‡:** é“¶è¡Œå®¶ç®—æ³•æ˜¯ä¸€ç§**æ­»é”é¿å…**ç®—æ³•ã€‚å®ƒé€šè¿‡æ£€æŸ¥æ¯ä¸€ä¸ªèµ„æºè¯·æ±‚æ¥ç¡®ä¿ç³»ç»Ÿå§‹ç»ˆå¤„äº**â€œå®‰å…¨çŠ¶æ€â€**ã€‚å®‰å…¨çŠ¶æ€æ˜¯æŒ‡å­˜åœ¨è‡³å°‘ä¸€ä¸ªèƒ½è®©æ‰€æœ‰è¿›ç¨‹éƒ½é¡ºåˆ©å®Œæˆè€Œä¸ä¼šå‘ç”Ÿæ­»é”çš„æ‰§è¡Œåºåˆ—ã€‚å¦‚æœä¸€ä¸ªèµ„æºè¯·æ±‚ä¼šå¯¼è‡´ä¸å®‰å…¨çŠ¶æ€ï¼Œè¯¥è¯·æ±‚å°†è¢«æ‹’ç»ã€‚

#### **Example Data Set / ç¤ºä¾‹æ•°æ®é›†**

*   **Processes / è¿›ç¨‹:** P0, P1, P2
*   **Resource Types / èµ„æºç±»å‹:** A, B, C
*   **Total System Resources / ç³»ç»Ÿæ€»èµ„æº:** **A=9, B=3, C=6**

---

### **Part 1: Is the initial system state safe? / ç¬¬ä¸€éƒ¨åˆ†ï¼šåˆå§‹ç³»ç»ŸçŠ¶æ€æ˜¯å¦å®‰å…¨ï¼Ÿ**

#### **Step 1: Initial State and Need Calculation / æ­¥éª¤1ï¼šåˆå§‹çŠ¶æ€ä¸éœ€æ±‚è®¡ç®—**

*   **EN:** This is the current snapshot of the system.
*   **ä¸­æ–‡:** è¿™æ˜¯ç³»ç»Ÿå½“å‰çš„å¿«ç…§ã€‚

| Process | Allocation (A B C) | Max (A B C) |
| :------ | :----------------- | :---------- |
| P0      | 1 0 0              | 4 3 3       |
| P1      | 3 1 2              | 5 2 2       |
| P2      | 2 1 1              | 3 3 2       |

*   **EN:** First, we calculate the `Available` resources and the `Need` matrix (`Need = Max - Allocation`).
*   **ä¸­æ–‡:** é¦–å…ˆï¼Œæˆ‘ä»¬è®¡ç®— `Available` (å¯ç”¨èµ„æº) å’Œ `Need` (éœ€æ±‚) çŸ©é˜µ (`Need = Max - Allocation`)ã€‚

*   **Total Allocated (å·²åˆ†é…æ€»é‡):**
    *   A: 1 + 3 + 2 = 6
    *   B: 0 + 1 + 1 = 2
    *   C: 0 + 2 + 1 = 3
*   **Available = Total - Allocated:**
    *   A: 9 - 6 = 3
    *   B: 3 - 2 = 1
    *   C: 6 - 3 = 3
    *   **Available = [3, 1, 3]**

*   **Need Matrix (éœ€æ±‚çŸ©é˜µ):**

| Process | Need (A B C) |
| :------ | :----------- |
| P0      | 3 3 3        |
| P1      | 2 1 0        |
| P2      | 1 2 1        |

#### **Step 2: Apply the Safety Algorithm / æ­¥éª¤2ï¼šåº”ç”¨å®‰å…¨ç®—æ³•**

*   **EN:** We check for a process `Pi` where `Need[i] <= Work`. We start with `Work = Available`.
*   **ä¸­æ–‡:** æˆ‘ä»¬å¯»æ‰¾æ˜¯å¦å­˜åœ¨ä¸€ä¸ªè¿›ç¨‹ `Pi` æ»¡è¶³ `Need[i] <= Work`ã€‚æˆ‘ä»¬ä» `Work = Available` å¼€å§‹ã€‚

**Let Work = Available = [3, 1, 3]**

1.  **Check P0:** `Need(3,3,3)` is **not <=** `Work(3,1,3)`. (Needs 3 of B, only 1 available). **P0 must wait.**
    **æ£€æŸ¥ P0:** `Need(3,3,3)` **ä¸æ»¡è¶³ <=** `Work(3,1,3)`ã€‚ï¼ˆéœ€è¦3ä¸ªBï¼Œä½†åªæœ‰1ä¸ªå¯ç”¨ï¼‰ã€‚**P0å¿…é¡»ç­‰å¾…ã€‚**
2.  **Check P1:** `Need(2,1,0)` **is <=** `Work(3,1,3)`. **Success!** P1 can run.
    **æ£€æŸ¥ P1:** `Need(2,1,0)` **æ»¡è¶³ <=** `Work(3,1,3)`ã€‚**æˆåŠŸï¼** P1å¯ä»¥è¿è¡Œã€‚
    *   **EN:** We simulate P1 finishing and releasing its resources.
    *   **ä¸­æ–‡:** æˆ‘ä»¬æ¨¡æ‹ŸP1å®Œæˆå¹¶é‡Šæ”¾å…¶èµ„æºã€‚
    *   `Work = Work + Allocation[P1] = [3,1,3] + [3,1,2] = [6,2,5]`
    *   **Safe Sequence so far: <P1>**
3.  **Check P2** (with new Work): `Need(1,2,1)` **is <=** `Work(6,2,5)`. **Success!** P2 can run.
    **æ£€æŸ¥ P2** (ä½¿ç”¨æ–°çš„ Work): `Need(1,2,1)` **æ»¡è¶³ <=** `Work(6,2,5)`ã€‚**æˆåŠŸï¼** P2å¯ä»¥è¿è¡Œã€‚
    *   **EN:** Simulate P2 finishing.
    *   **ä¸­æ–‡:** æ¨¡æ‹ŸP2å®Œæˆã€‚
    *   `Work = Work + Allocation[P2] = [6,2,5] + [2,1,1] = [8,3,6]`
    *   **Safe Sequence so far: <P1, P2>**
4.  **Check P0 again** (with new Work): `Need(3,3,3)` **is <=** `Work(8,3,6)`. **Success!** P0 can run.
    **å†æ¬¡æ£€æŸ¥ P0** (ä½¿ç”¨æ–°çš„ Work): `Need(3,3,3)` **æ»¡è¶³ <=** `Work(8,3,6)`ã€‚**æˆåŠŸï¼** P0å¯ä»¥è¿è¡Œã€‚
    *   **Final Safe Sequence: <P1, P2, P0>**

#### **Conclusion for Part 1 / ç¬¬ä¸€éƒ¨åˆ†ç»“è®º**

*   **EN:** Yes, the system is in a **safe state**. A safe sequence is **<P1, P2, P0>**.
*   **ä¸­æ–‡:** æ˜¯çš„ï¼Œç³»ç»Ÿå¤„äº**å®‰å…¨çŠ¶æ€**ã€‚ä¸€ä¸ªå®‰å…¨åºåˆ—æ˜¯ **<P1, P2, P0>**ã€‚

---

### **Part 2: What if P2 requests (1,1,0)? / ç¬¬äºŒéƒ¨åˆ†ï¼šå¦‚æœ P2 è¯·æ±‚ (1,1,0) ä¼šæ€æ ·ï¼Ÿ**

#### **Step 1: Check if the request is valid / æ­¥éª¤1ï¼šæ£€æŸ¥è¯·æ±‚æ˜¯å¦æœ‰æ•ˆ**

1.  **EN:** Is `Request(1,1,0)` <= `Need[P2](1,2,1)`? **Yes.** (The process is not asking for more than it said it would need).
    **ä¸­æ–‡:** `Request(1,1,0)` æ˜¯å¦ <= `Need[P2](1,2,1)`ï¼Ÿ**æ˜¯ã€‚** (è¿›ç¨‹è¯·æ±‚çš„æ²¡æœ‰è¶…è¿‡å®ƒå£°æ˜çš„æœ€å¤§éœ€æ±‚)ã€‚
2.  **EN:** Is `Request(1,1,0)` <= `Available(3,1,3)`? **Yes.** (The system has enough resources to fulfill the request right now).
    **ä¸­æ–‡:** `Request(1,1,0)` æ˜¯å¦ <= `Available(3,1,3)`ï¼Ÿ**æ˜¯ã€‚** (ç³»ç»Ÿå½“å‰æœ‰è¶³å¤Ÿçš„èµ„æºæ¥æ»¡è¶³è¯¥è¯·æ±‚)ã€‚

Since both checks pass, we must proceed to the safety check.
ç”±äºä¸¤ä¸ªæ£€æŸ¥éƒ½é€šè¿‡äº†ï¼Œæˆ‘ä»¬å¿…é¡»ç»§ç»­è¿›è¡Œå®‰å…¨æ£€æŸ¥ã€‚

#### **Step 2: Create the Hypothetical State / æ­¥éª¤2ï¼šåˆ›å»ºå‡è®¾çŠ¶æ€**

*   **EN:** We pretend to grant the request and update the system state.
*   **ä¸­æ–‡:** æˆ‘ä»¬å‡è®¾æ‰¹å‡†è¯¥è¯·æ±‚å¹¶æ›´æ–°ç³»ç»ŸçŠ¶æ€ã€‚
*   `Available` becomes `[3,1,3] - [1,1,0] = [2,0,3]`
*   `Allocation[P2]` becomes `[2,1,1] + [1,1,0] = [3,2,1]`
*   `Need[P2]` becomes `[1,2,1] - [1,1,0] = [0,1,1]`

#### **Step 3: Run the Safety Algorithm on the NEW state / æ­¥éª¤3ï¼šå¯¹æ–°çŠ¶æ€è¿è¡Œå®‰å…¨ç®—æ³•**

**Let Work = New Available = [2, 0, 3]**

1.  **Check P0:** `Need(3,3,3)` is **not <=** `Work(2,0,3)`. **P0 must wait.**
    **æ£€æŸ¥ P0:** `Need(3,3,3)` **ä¸æ»¡è¶³ <=** `Work(2,0,3)`ã€‚**P0å¿…é¡»ç­‰å¾…ã€‚**
2.  **Check P1:** `Need(2,1,0)` is **not <=** `Work(2,0,3)`. (Needs 1 of B, 0 available). **P1 must wait.**
    **æ£€æŸ¥ P1:** `Need(2,1,0)` **ä¸æ»¡è¶³ <=** `Work(2,0,3)`ã€‚(éœ€è¦1ä¸ªBï¼Œä½†0ä¸ªå¯ç”¨)ã€‚**P1å¿…é¡»ç­‰å¾…ã€‚**
3.  **Check P2:** `Need(0,1,1)` is **not <=** `Work(2,0,3)`. (Needs 1 of B, 0 available). **P2 must wait.**
    **æ£€æŸ¥ P2:** `Need(0,1,1)` **ä¸æ»¡è¶³ <=** `Work(2,0,3)`ã€‚(éœ€è¦1ä¸ªBï¼Œä½†0ä¸ªå¯ç”¨)ã€‚**P2å¿…é¡»ç­‰å¾…ã€‚**

*   **EN:** We have gone through all processes, and **not a single one can run**. The system is stuck.
*   **ä¸­æ–‡:** æˆ‘ä»¬å·²ç»æ£€æŸ¥äº†æ‰€æœ‰è¿›ç¨‹ï¼Œ**æ²¡æœ‰ä¸€ä¸ªå¯ä»¥è¿è¡Œ**ã€‚ç³»ç»Ÿå¡ä½äº†ã€‚

#### **Conclusion for Part 2 / ç¬¬äºŒéƒ¨åˆ†ç»“è®º**

*   **EN:** The resulting hypothetical state is **UNSAFE**. Therefore, the Banker's Algorithm dictates that the OS **must deny the request** from P2. P2 is placed in a waiting state, and the system is not changed.
*   **ä¸­æ–‡:** æœ€ç»ˆçš„å‡è®¾çŠ¶æ€æ˜¯**ä¸å®‰å…¨çš„**ã€‚å› æ­¤ï¼Œé“¶è¡Œå®¶ç®—æ³•è§„å®šæ“ä½œç³»ç»Ÿ**å¿…é¡»æ‹’ç» P2 çš„è¯·æ±‚**ã€‚P2è¢«ç½®äºç­‰å¾…çŠ¶æ€ï¼Œç³»ç»ŸçŠ¶æ€ä¿æŒä¸å˜ã€‚
